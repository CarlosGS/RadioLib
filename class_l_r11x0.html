<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: LR11x0 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_l_r11x0.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_l_r11x0-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LR11x0 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for LR11x0:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_l_r11x0.png" usemap="#LR11x0_map" alt=""/>
  <map id="LR11x0_map" name="LR11x0_map">
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="0,0,93,24"/>
<area href="class_l_r1110.html" title="Derived class for LR1110 modules." alt="LR1110" shape="rect" coords="0,112,93,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a562f34a054e3374b812556df3b6eb421"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a562f34a054e3374b812556df3b6eb421">LR11x0</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:a562f34a054e3374b812556df3b6eb421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_l_r11x0.html#a562f34a054e3374b812556df3b6eb421">More...</a><br /></td></tr>
<tr class="separator:a562f34a054e3374b812556df3b6eb421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc6468762c36c30e9af262014e17942"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a8dc6468762c36c30e9af262014e17942">begin</a> (float bw, uint8_t sf, uint8_t cr, uint8_t syncWord, uint16_t preambleLength, float tcxoVoltage)</td></tr>
<tr class="memdesc:a8dc6468762c36c30e9af262014e17942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for LoRa modem.  <a href="class_l_r11x0.html#a8dc6468762c36c30e9af262014e17942">More...</a><br /></td></tr>
<tr class="separator:a8dc6468762c36c30e9af262014e17942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc4c776d1a09bb002226ac95574766d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#abcc4c776d1a09bb002226ac95574766d">beginGFSK</a> (float br, float freqDev, float rxBw, uint16_t preambleLength, float tcxoVoltage)</td></tr>
<tr class="memdesc:abcc4c776d1a09bb002226ac95574766d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for FSK modem.  <a href="class_l_r11x0.html#abcc4c776d1a09bb002226ac95574766d">More...</a><br /></td></tr>
<tr class="separator:abcc4c776d1a09bb002226ac95574766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858b08fd0e7b00baf3056d32dfabb87e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a858b08fd0e7b00baf3056d32dfabb87e">beginLRFHSS</a> (uint8_t bw, uint8_t cr, float tcxoVoltage)</td></tr>
<tr class="memdesc:a858b08fd0e7b00baf3056d32dfabb87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for LR-FHSS modem.  <a href="class_l_r11x0.html#a858b08fd0e7b00baf3056d32dfabb87e">More...</a><br /></td></tr>
<tr class="separator:a858b08fd0e7b00baf3056d32dfabb87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288bcc309d3676bc0bbe620b7d89d994"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a288bcc309d3676bc0bbe620b7d89d994">reset</a> ()</td></tr>
<tr class="memdesc:a288bcc309d3676bc0bbe620b7d89d994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method. Will reset the chip to the default state using RST pin.  <a href="class_l_r11x0.html#a288bcc309d3676bc0bbe620b7d89d994">More...</a><br /></td></tr>
<tr class="separator:a288bcc309d3676bc0bbe620b7d89d994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1de95be55f7ecc1d26a7aa7983cdba"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a3a1de95be55f7ecc1d26a7aa7983cdba">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a3a1de95be55f7ecc1d26a7aa7983cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_l_r11x0.html#a3a1de95be55f7ecc1d26a7aa7983cdba">More...</a><br /></td></tr>
<tr class="separator:a3a1de95be55f7ecc1d26a7aa7983cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377c287f18c939c2b4da3241d8329e58"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a377c287f18c939c2b4da3241d8329e58">receive</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:a377c287f18c939c2b4da3241d8329e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_l_r11x0.html#a377c287f18c939c2b4da3241d8329e58">More...</a><br /></td></tr>
<tr class="separator:a377c287f18c939c2b4da3241d8329e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae077957969f6274a53f63b314b6f1359"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ae077957969f6274a53f63b314b6f1359">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:ae077957969f6274a53f63b314b6f1359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts direct mode transmission.  <a href="class_l_r11x0.html#ae077957969f6274a53f63b314b6f1359">More...</a><br /></td></tr>
<tr class="separator:ae077957969f6274a53f63b314b6f1359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a8e8eda78113c47f1a865e63051bb5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ae1a8e8eda78113c47f1a865e63051bb5">receiveDirect</a> () override</td></tr>
<tr class="memdesc:ae1a8e8eda78113c47f1a865e63051bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts direct mode reception. Only implemented for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, as SX126x series does not support direct mode reception. Will always return RADIOLIB_ERR_UNKNOWN.  <a href="class_l_r11x0.html#ae1a8e8eda78113c47f1a865e63051bb5">More...</a><br /></td></tr>
<tr class="separator:ae1a8e8eda78113c47f1a865e63051bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3034c91f5bce70c853ab1620725b3c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a6a3034c91f5bce70c853ab1620725b3c">scanChannel</a> () override</td></tr>
<tr class="memdesc:a6a3034c91f5bce70c853ab1620725b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for LoRa transmission in the current channel. Detects both preamble and payload.  <a href="class_l_r11x0.html#a6a3034c91f5bce70c853ab1620725b3c">More...</a><br /></td></tr>
<tr class="separator:a6a3034c91f5bce70c853ab1620725b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ece57e55ee0001671165213b409a44"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a99ece57e55ee0001671165213b409a44">scanChannel</a> (uint8_t symbolNum, uint8_t detPeak, uint8_t detMin)</td></tr>
<tr class="memdesc:a99ece57e55ee0001671165213b409a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for LoRa transmission in the current channel. Detects both preamble and payload.  <a href="class_l_r11x0.html#a99ece57e55ee0001671165213b409a44">More...</a><br /></td></tr>
<tr class="separator:a99ece57e55ee0001671165213b409a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c3f3f8409f1fd0f41347b7d3c7dc24"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a74c3f3f8409f1fd0f41347b7d3c7dc24">standby</a> () override</td></tr>
<tr class="memdesc:a74c3f3f8409f1fd0f41347b7d3c7dc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode (overload for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, uses 13 MHz RC oscillator).  <a href="class_l_r11x0.html#a74c3f3f8409f1fd0f41347b7d3c7dc24">More...</a><br /></td></tr>
<tr class="separator:a74c3f3f8409f1fd0f41347b7d3c7dc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d682ec2ca0ddf4da41a93dd8e728665"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a2d682ec2ca0ddf4da41a93dd8e728665">standby</a> (uint8_t mode, bool wakeup=true)</td></tr>
<tr class="memdesc:a2d682ec2ca0ddf4da41a93dd8e728665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode.  <a href="class_l_r11x0.html#a2d682ec2ca0ddf4da41a93dd8e728665">More...</a><br /></td></tr>
<tr class="separator:a2d682ec2ca0ddf4da41a93dd8e728665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d70a3341a6a8b32f9871cdcb719733"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a64d70a3341a6a8b32f9871cdcb719733">sleep</a> (bool retainConfig=true, uint32_t sleepTime=0)</td></tr>
<tr class="memdesc:a64d70a3341a6a8b32f9871cdcb719733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to sleep mode. To wake the device up, call <a class="el" href="class_l_r11x0.html#a74c3f3f8409f1fd0f41347b7d3c7dc24" title="Sets the module to standby mode (overload for PhysicalLayer compatibility, uses 13 MHz RC oscillator)...">standby()</a>.  <a href="class_l_r11x0.html#a64d70a3341a6a8b32f9871cdcb719733">More...</a><br /></td></tr>
<tr class="separator:a64d70a3341a6a8b32f9871cdcb719733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49116d006b60128fe6f73a6a868a6d18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a49116d006b60128fe6f73a6a868a6d18">setIrqAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a49116d006b60128fe6f73a6a868a6d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when IRQ1 activates.  <a href="class_l_r11x0.html#a49116d006b60128fe6f73a6a868a6d18">More...</a><br /></td></tr>
<tr class="separator:a49116d006b60128fe6f73a6a868a6d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab167c4dc14e80d19f8b33d68c3f90d98"><td class="memItemLeft" align="right" valign="top"><a id="ab167c4dc14e80d19f8b33d68c3f90d98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ab167c4dc14e80d19f8b33d68c3f90d98">clearIrqAction</a> ()</td></tr>
<tr class="memdesc:ab167c4dc14e80d19f8b33d68c3f90d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when IRQ1 activates. <br /></td></tr>
<tr class="separator:ab167c4dc14e80d19f8b33d68c3f90d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4d48bf33fe466ea4c14cd9db228dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a0a4d48bf33fe466ea4c14cd9db228dce">setPacketReceivedAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a0a4d48bf33fe466ea4c14cd9db228dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is received.  <a href="class_l_r11x0.html#a0a4d48bf33fe466ea4c14cd9db228dce">More...</a><br /></td></tr>
<tr class="separator:a0a4d48bf33fe466ea4c14cd9db228dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a2afc6cef1e94e25efec15094816a8"><td class="memItemLeft" align="right" valign="top"><a id="a66a2afc6cef1e94e25efec15094816a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a66a2afc6cef1e94e25efec15094816a8">clearPacketReceivedAction</a> ()</td></tr>
<tr class="memdesc:a66a2afc6cef1e94e25efec15094816a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is received. <br /></td></tr>
<tr class="separator:a66a2afc6cef1e94e25efec15094816a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ff8c277e340c3273fb5715cd743cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a88ff8c277e340c3273fb5715cd743cce">setPacketSentAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a88ff8c277e340c3273fb5715cd743cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is sent.  <a href="class_l_r11x0.html#a88ff8c277e340c3273fb5715cd743cce">More...</a><br /></td></tr>
<tr class="separator:a88ff8c277e340c3273fb5715cd743cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd69e3b8825309703e13149b94e49d81"><td class="memItemLeft" align="right" valign="top"><a id="acd69e3b8825309703e13149b94e49d81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#acd69e3b8825309703e13149b94e49d81">clearPacketSentAction</a> ()</td></tr>
<tr class="memdesc:acd69e3b8825309703e13149b94e49d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is sent. <br /></td></tr>
<tr class="separator:acd69e3b8825309703e13149b94e49d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ab2acdf0e2a6c621be3a267119fcd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a548ab2acdf0e2a6c621be3a267119fcd">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a548ab2acdf0e2a6c621be3a267119fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_l_r11x0.html#a548ab2acdf0e2a6c621be3a267119fcd">More...</a><br /></td></tr>
<tr class="separator:a548ab2acdf0e2a6c621be3a267119fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff9a5b9b7636693c98bd1c93a5863e5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#aaff9a5b9b7636693c98bd1c93a5863e5">finishTransmit</a> () override</td></tr>
<tr class="memdesc:aaff9a5b9b7636693c98bd1c93a5863e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after transmission is done.  <a href="class_l_r11x0.html#aaff9a5b9b7636693c98bd1c93a5863e5">More...</a><br /></td></tr>
<tr class="separator:aaff9a5b9b7636693c98bd1c93a5863e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc154b86d9159fb5f769f62418d52b7"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#aabc154b86d9159fb5f769f62418d52b7">startReceive</a> ()</td></tr>
<tr class="memdesc:aabc154b86d9159fb5f769f62418d52b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method with default parameters. Implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_l_r11x0.html#aabc154b86d9159fb5f769f62418d52b7">More...</a><br /></td></tr>
<tr class="separator:aabc154b86d9159fb5f769f62418d52b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437eaf0e0541983751abd28db45efea8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a437eaf0e0541983751abd28db45efea8">startReceive</a> (uint32_t timeout, uint32_t irqFlags=RADIOLIB_LR11X0_IRQ_RX_DONE, size_t len=0)</td></tr>
<tr class="memdesc:a437eaf0e0541983751abd28db45efea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. IRQ1 will be activated when full packet is received.  <a href="class_l_r11x0.html#a437eaf0e0541983751abd28db45efea8">More...</a><br /></td></tr>
<tr class="separator:a437eaf0e0541983751abd28db45efea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0309154558a0d88e2e8957e4dbf6a2f8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a0309154558a0d88e2e8957e4dbf6a2f8">getIrqStatus</a> ()</td></tr>
<tr class="memdesc:a0309154558a0d88e2e8957e4dbf6a2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current IRQ status.  <a href="class_l_r11x0.html#a0309154558a0d88e2e8957e4dbf6a2f8">More...</a><br /></td></tr>
<tr class="separator:a0309154558a0d88e2e8957e4dbf6a2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20279f1b267e936991f47fd703924833"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a20279f1b267e936991f47fd703924833">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:a20279f1b267e936991f47fd703924833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData!  <a href="class_l_r11x0.html#a20279f1b267e936991f47fd703924833">More...</a><br /></td></tr>
<tr class="separator:a20279f1b267e936991f47fd703924833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3bc362530b85dd643669705f03998d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a4f3bc362530b85dd643669705f03998d">startChannelScan</a> () override</td></tr>
<tr class="memdesc:a4f3bc362530b85dd643669705f03998d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. IRQ1 will be activated when LoRa preamble is detected, or upon timeout. Defaults to CAD parameter values recommended by AN1200.48.  <a href="class_l_r11x0.html#a4f3bc362530b85dd643669705f03998d">More...</a><br /></td></tr>
<tr class="separator:a4f3bc362530b85dd643669705f03998d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09eb53b0c32a5f229e14c46bfe45a4f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#aa09eb53b0c32a5f229e14c46bfe45a4f">startChannelScan</a> (uint8_t symbolNum, uint8_t detPeak, uint8_t detMin)</td></tr>
<tr class="memdesc:aa09eb53b0c32a5f229e14c46bfe45a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. IRQ1 will be activated when LoRa preamble is detected, or upon timeout.  <a href="class_l_r11x0.html#aa09eb53b0c32a5f229e14c46bfe45a4f">More...</a><br /></td></tr>
<tr class="separator:aa09eb53b0c32a5f229e14c46bfe45a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae2cddeb7671d9b71e9c83bf020820f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a1ae2cddeb7671d9b71e9c83bf020820f">getChannelScanResult</a> () override</td></tr>
<tr class="memdesc:a1ae2cddeb7671d9b71e9c83bf020820f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the channel scan result.  <a href="class_l_r11x0.html#a1ae2cddeb7671d9b71e9c83bf020820f">More...</a><br /></td></tr>
<tr class="separator:a1ae2cddeb7671d9b71e9c83bf020820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf961ec7d93feb6472f26b7b976ee0c9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#abf961ec7d93feb6472f26b7b976ee0c9">setBandwidth</a> (float bw)</td></tr>
<tr class="memdesc:abf961ec7d93feb6472f26b7b976ee0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa bandwidth. Allowed values are 62.5, 125.0, 250.0 and 500.0 kHz.  <a href="class_l_r11x0.html#abf961ec7d93feb6472f26b7b976ee0c9">More...</a><br /></td></tr>
<tr class="separator:abf961ec7d93feb6472f26b7b976ee0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6895cbf7af7e00ea06c5b2b5040cb4"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#adf6895cbf7af7e00ea06c5b2b5040cb4">setSpreadingFactor</a> (uint8_t sf, bool legacy=false)</td></tr>
<tr class="memdesc:adf6895cbf7af7e00ea06c5b2b5040cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa spreading factor. Allowed values range from 5 to 12.  <a href="class_l_r11x0.html#adf6895cbf7af7e00ea06c5b2b5040cb4">More...</a><br /></td></tr>
<tr class="separator:adf6895cbf7af7e00ea06c5b2b5040cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583f2d5ed601a98c609dbf0d57f2f541"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a583f2d5ed601a98c609dbf0d57f2f541">setCodingRate</a> (uint8_t cr, bool longInterleave=false)</td></tr>
<tr class="memdesc:a583f2d5ed601a98c609dbf0d57f2f541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa coding rate denominator. Allowed values range from 5 to 8.  <a href="class_l_r11x0.html#a583f2d5ed601a98c609dbf0d57f2f541">More...</a><br /></td></tr>
<tr class="separator:a583f2d5ed601a98c609dbf0d57f2f541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffa48f1b6aaaa3f48e4b51f8ada59d8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a7ffa48f1b6aaaa3f48e4b51f8ada59d8">setSyncWord</a> (uint32_t syncWord)</td></tr>
<tr class="memdesc:a7ffa48f1b6aaaa3f48e4b51f8ada59d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa or LR-FHSS sync word.  <a href="class_l_r11x0.html#a7ffa48f1b6aaaa3f48e4b51f8ada59d8">More...</a><br /></td></tr>
<tr class="separator:a7ffa48f1b6aaaa3f48e4b51f8ada59d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ab7a24fec379c6ba2d642e1133c4f2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a03ab7a24fec379c6ba2d642e1133c4f2">setBitRate</a> (float br)</td></tr>
<tr class="memdesc:a03ab7a24fec379c6ba2d642e1133c4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK bit rate. Allowed values range from 0.6 to 300.0 kbps.  <a href="class_l_r11x0.html#a03ab7a24fec379c6ba2d642e1133c4f2">More...</a><br /></td></tr>
<tr class="separator:a03ab7a24fec379c6ba2d642e1133c4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003cfe3a4dbd9bad1f01fd0147031d1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ac003cfe3a4dbd9bad1f01fd0147031d1">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:ac003cfe3a4dbd9bad1f01fd0147031d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK frequency deviation. Allowed values range from 0.0 to 200.0 kHz.  <a href="class_l_r11x0.html#ac003cfe3a4dbd9bad1f01fd0147031d1">More...</a><br /></td></tr>
<tr class="separator:ac003cfe3a4dbd9bad1f01fd0147031d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f5ee68b3c2638ae613c87ed1c3fc64"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a25f5ee68b3c2638ae613c87ed1c3fc64">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a25f5ee68b3c2638ae613c87ed1c3fc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK receiver bandwidth. Allowed values are 4.8, 5.8, 7.3, 9.7, 11.7, 14.6, 19.5, 23.4, 29.3, 39.0, 46.9, 58.6, 78.2, 93.8, 117.3, 156.2, 187.2, 234.3, 312.0, 373.6 and 467.0 kHz.  <a href="class_l_r11x0.html#a25f5ee68b3c2638ae613c87ed1c3fc64">More...</a><br /></td></tr>
<tr class="separator:a25f5ee68b3c2638ae613c87ed1c3fc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c54b1b105605ffe0908c5ff9362932"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ab8c54b1b105605ffe0908c5ff9362932">setSyncWord</a> (uint8_t *syncWord, size_t len) override</td></tr>
<tr class="memdesc:ab8c54b1b105605ffe0908c5ff9362932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK sync word in the form of array of up to 8 bytes.  <a href="class_l_r11x0.html#ab8c54b1b105605ffe0908c5ff9362932">More...</a><br /></td></tr>
<tr class="separator:ab8c54b1b105605ffe0908c5ff9362932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6501ef362df1a5b71927cfe4e43c202d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a6501ef362df1a5b71927cfe4e43c202d">setSyncBits</a> (uint8_t *syncWord, uint8_t bitsLen)</td></tr>
<tr class="memdesc:a6501ef362df1a5b71927cfe4e43c202d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK sync word in the form of array of up to 8 bytes.  <a href="class_l_r11x0.html#a6501ef362df1a5b71927cfe4e43c202d">More...</a><br /></td></tr>
<tr class="separator:a6501ef362df1a5b71927cfe4e43c202d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f5c74ce523abad256866abe133d2e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a605f5c74ce523abad256866abe133d2e">setNodeAddress</a> (uint8_t nodeAddr)</td></tr>
<tr class="memdesc:a605f5c74ce523abad256866abe133d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets node address. Calling this method will also enable address filtering for node address only.  <a href="class_l_r11x0.html#a605f5c74ce523abad256866abe133d2e">More...</a><br /></td></tr>
<tr class="separator:a605f5c74ce523abad256866abe133d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24ba794f71c4e37cd13d2f4dbec5bf7"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#af24ba794f71c4e37cd13d2f4dbec5bf7">setBroadcastAddress</a> (uint8_t broadAddr)</td></tr>
<tr class="memdesc:af24ba794f71c4e37cd13d2f4dbec5bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets broadcast address. Calling this method will also enable address filtering for node and broadcast address.  <a href="class_l_r11x0.html#af24ba794f71c4e37cd13d2f4dbec5bf7">More...</a><br /></td></tr>
<tr class="separator:af24ba794f71c4e37cd13d2f4dbec5bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae565dc2423ca7df13bf7ae48cce9ac8b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ae565dc2423ca7df13bf7ae48cce9ac8b">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:ae565dc2423ca7df13bf7ae48cce9ac8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables address filtering. Calling this method will also erase previously set addresses.  <a href="class_l_r11x0.html#ae565dc2423ca7df13bf7ae48cce9ac8b">More...</a><br /></td></tr>
<tr class="separator:ae565dc2423ca7df13bf7ae48cce9ac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a33df702da3f5b010e07d5e6fac7aa6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a5a33df702da3f5b010e07d5e6fac7aa6">setDataShaping</a> (uint8_t sh) override</td></tr>
<tr class="memdesc:a5a33df702da3f5b010e07d5e6fac7aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets time-bandwidth product of Gaussian filter applied for shaping. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5, RADIOLIB_SHAPING_0_7 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping.  <a href="class_l_r11x0.html#a5a33df702da3f5b010e07d5e6fac7aa6">More...</a><br /></td></tr>
<tr class="separator:a5a33df702da3f5b010e07d5e6fac7aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae178a17f6e41b545b79cfffd3e2864"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a8ae178a17f6e41b545b79cfffd3e2864">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:a8ae178a17f6e41b545b79cfffd3e2864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Available in GFSK mode only. Serves only as alias for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <a href="class_l_r11x0.html#a8ae178a17f6e41b545b79cfffd3e2864">More...</a><br /></td></tr>
<tr class="separator:a8ae178a17f6e41b545b79cfffd3e2864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df4c1ed45bf59aa25bc400bcb5dc1ba"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a5df4c1ed45bf59aa25bc400bcb5dc1ba">fixedPacketLengthMode</a> (uint8_t len=RADIOLIB_LR11X0_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:a5df4c1ed45bf59aa25bc400bcb5dc1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode. Available in GFSK mode only.  <a href="class_l_r11x0.html#a5df4c1ed45bf59aa25bc400bcb5dc1ba">More...</a><br /></td></tr>
<tr class="separator:a5df4c1ed45bf59aa25bc400bcb5dc1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd56cf63e91449b6cd03782a69c3451"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#adcd56cf63e91449b6cd03782a69c3451">variablePacketLengthMode</a> (uint8_t maxLen=RADIOLIB_LR11X0_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:adcd56cf63e91449b6cd03782a69c3451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode. Available in GFSK mode only.  <a href="class_l_r11x0.html#adcd56cf63e91449b6cd03782a69c3451">More...</a><br /></td></tr>
<tr class="separator:adcd56cf63e91449b6cd03782a69c3451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcde55b8660c24cf5783942a4132786d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#adcde55b8660c24cf5783942a4132786d">setWhitening</a> (bool enabled, uint16_t initial=0x01FF)</td></tr>
<tr class="memdesc:adcde55b8660c24cf5783942a4132786d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK whitening parameters.  <a href="class_l_r11x0.html#adcde55b8660c24cf5783942a4132786d">More...</a><br /></td></tr>
<tr class="separator:adcde55b8660c24cf5783942a4132786d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e65c58ff8fb18bd84917512790ee6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a056e65c58ff8fb18bd84917512790ee6">setDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr) override</td></tr>
<tr class="memdesc:a056e65c58ff8fb18bd84917512790ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data.  <a href="class_l_r11x0.html#a056e65c58ff8fb18bd84917512790ee6">More...</a><br /></td></tr>
<tr class="separator:a056e65c58ff8fb18bd84917512790ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d18ad719be79c083f2b0ce77bbaa448"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a4d18ad719be79c083f2b0ce77bbaa448">checkDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr) override</td></tr>
<tr class="memdesc:a4d18ad719be79c083f2b0ce77bbaa448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the data rate can be configured by this module.  <a href="class_l_r11x0.html#a4d18ad719be79c083f2b0ce77bbaa448">More...</a><br /></td></tr>
<tr class="separator:a4d18ad719be79c083f2b0ce77bbaa448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d7ae65666f8f9abcb7e9b169884a4a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#aa5d7ae65666f8f9abcb7e9b169884a4a">setPreambleLength</a> (size_t preambleLength) override</td></tr>
<tr class="memdesc:aa5d7ae65666f8f9abcb7e9b169884a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length for LoRa or GFSK modem. Allowed values range from 1 to 65535.  <a href="class_l_r11x0.html#aa5d7ae65666f8f9abcb7e9b169884a4a">More...</a><br /></td></tr>
<tr class="separator:aa5d7ae65666f8f9abcb7e9b169884a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971b4ccd1d5479e9d72aa9649e8fef55"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a971b4ccd1d5479e9d72aa9649e8fef55">setTCXO</a> (float voltage, uint32_t delay=5000)</td></tr>
<tr class="memdesc:a971b4ccd1d5479e9d72aa9649e8fef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets TCXO (Temperature Compensated Crystal Oscillator) configuration.  <a href="class_l_r11x0.html#a971b4ccd1d5479e9d72aa9649e8fef55">More...</a><br /></td></tr>
<tr class="separator:a971b4ccd1d5479e9d72aa9649e8fef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551b82787288b0b14e4d3124e6744dc3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a551b82787288b0b14e4d3124e6744dc3">setCRC</a> (uint8_t len, uint32_t initial=0x00001D0FUL, uint32_t polynomial=0x00001021UL, bool inverted=true)</td></tr>
<tr class="memdesc:a551b82787288b0b14e4d3124e6744dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets CRC configuration.  <a href="class_l_r11x0.html#a551b82787288b0b14e4d3124e6744dc3">More...</a><br /></td></tr>
<tr class="separator:a551b82787288b0b14e4d3124e6744dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85c16956c2250dbf338a298c074d28c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#af85c16956c2250dbf338a298c074d28c">invertIQ</a> (bool enable) override</td></tr>
<tr class="memdesc:af85c16956c2250dbf338a298c074d28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable inversion of the I and Q signals.  <a href="class_l_r11x0.html#af85c16956c2250dbf338a298c074d28c">More...</a><br /></td></tr>
<tr class="separator:af85c16956c2250dbf338a298c074d28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468ee0182883d8af22a0a4202ef7baa5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a468ee0182883d8af22a0a4202ef7baa5">getRSSI</a> ()</td></tr>
<tr class="memdesc:a468ee0182883d8af22a0a4202ef7baa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets RSSI (Recorded Signal Strength Indicator) of the last received packet. Only available for LoRa or GFSK modem.  <a href="class_l_r11x0.html#a468ee0182883d8af22a0a4202ef7baa5">More...</a><br /></td></tr>
<tr class="separator:a468ee0182883d8af22a0a4202ef7baa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f32509aea96de6a7ec08a8e60a6bea"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ad4f32509aea96de6a7ec08a8e60a6bea">getSNR</a> ()</td></tr>
<tr class="memdesc:ad4f32509aea96de6a7ec08a8e60a6bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem.  <a href="class_l_r11x0.html#ad4f32509aea96de6a7ec08a8e60a6bea">More...</a><br /></td></tr>
<tr class="separator:ad4f32509aea96de6a7ec08a8e60a6bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9046bccdb4ef60718e2e8ed2bd7f036"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ad9046bccdb4ef60718e2e8ed2bd7f036">getFrequencyError</a> ()</td></tr>
<tr class="memdesc:ad9046bccdb4ef60718e2e8ed2bd7f036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets frequency error of the latest received packet.  <a href="class_l_r11x0.html#ad9046bccdb4ef60718e2e8ed2bd7f036">More...</a><br /></td></tr>
<tr class="separator:ad9046bccdb4ef60718e2e8ed2bd7f036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f541bdee1d983126ceae47940b8f9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ac1f541bdee1d983126ceae47940b8f9d">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:ac1f541bdee1d983126ceae47940b8f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <a href="class_l_r11x0.html#ac1f541bdee1d983126ceae47940b8f9d">More...</a><br /></td></tr>
<tr class="separator:ac1f541bdee1d983126ceae47940b8f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96883b2ca7a36a8921ee1cd222adebf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#af96883b2ca7a36a8921ee1cd222adebf">getPacketLength</a> (bool update, uint8_t *offset)</td></tr>
<tr class="memdesc:af96883b2ca7a36a8921ee1cd222adebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <a href="class_l_r11x0.html#af96883b2ca7a36a8921ee1cd222adebf">More...</a><br /></td></tr>
<tr class="separator:af96883b2ca7a36a8921ee1cd222adebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dd234876e6e5dc640302d8456fd7ed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a33dd234876e6e5dc640302d8456fd7ed">getTimeOnAir</a> (size_t len) override</td></tr>
<tr class="memdesc:a33dd234876e6e5dc640302d8456fd7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expected time-on-air for a given size of payload.  <a href="class_l_r11x0.html#a33dd234876e6e5dc640302d8456fd7ed">More...</a><br /></td></tr>
<tr class="separator:a33dd234876e6e5dc640302d8456fd7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec81f3625fdc8a3ef6c54a3804c3aa9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a1ec81f3625fdc8a3ef6c54a3804c3aa9">getDataRate</a> () const</td></tr>
<tr class="memdesc:a1ec81f3625fdc8a3ef6c54a3804c3aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets effective data rate for the last transmitted packet. The value is calculated only for payload bytes.  <a href="class_l_r11x0.html#a1ec81f3625fdc8a3ef6c54a3804c3aa9">More...</a><br /></td></tr>
<tr class="separator:a1ec81f3625fdc8a3ef6c54a3804c3aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1def9a01021a52f5bb82c119a9ad35"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a8c1def9a01021a52f5bb82c119a9ad35">setLrFhssConfig</a> (uint8_t bw, uint8_t cr, uint8_t hdrCount=3, uint16_t hopSeed=0x13A)</td></tr>
<tr class="memdesc:a8c1def9a01021a52f5bb82c119a9ad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LR-FHSS configuration.  <a href="class_l_r11x0.html#a8c1def9a01021a52f5bb82c119a9ad35">More...</a><br /></td></tr>
<tr class="separator:a8c1def9a01021a52f5bb82c119a9ad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_l_r11x0.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd42f8d5569487ea74f004ca652a709"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a3dd42f8d5569487ea74f004ca652a709">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:a3dd42f8d5569487ea74f004ca652a709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <a href="class_l_r11x0.html#a3dd42f8d5569487ea74f004ca652a709">More...</a><br /></td></tr>
<tr class="separator:a3dd42f8d5569487ea74f004ca652a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82617fa3fa9f21d4cd427314ecc4af8"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ab82617fa3fa9f21d4cd427314ecc4af8">receive</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:ab82617fa3fa9f21d4cd427314ecc4af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <a href="class_l_r11x0.html#ab82617fa3fa9f21d4cd427314ecc4af8">More...</a><br /></td></tr>
<tr class="separator:ab82617fa3fa9f21d4cd427314ecc4af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_l_r11x0.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59e37ce0606dc8051e40be9d14cfec3"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#ad59e37ce0606dc8051e40be9d14cfec3">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:ad59e37ce0606dc8051e40be9d14cfec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <a href="class_l_r11x0.html#ad59e37ce0606dc8051e40be9d14cfec3">More...</a><br /></td></tr>
<tr class="separator:ad59e37ce0606dc8051e40be9d14cfec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563453988a83d22dd07d4691543a300"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a3563453988a83d22dd07d4691543a300">readData</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a3563453988a83d22dd07d4691543a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_l_r11x0.html#a3563453988a83d22dd07d4691543a300">More...</a><br /></td></tr>
<tr class="separator:a3563453988a83d22dd07d4691543a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:add63d7d4fa8b14df5e185813794a49d5 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#add63d7d4fa8b14df5e185813794a49d5">PhysicalLayer</a> (float step, size_t maxLen)</td></tr>
<tr class="memdesc:add63d7d4fa8b14df5e185813794a49d5 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_physical_layer.html#add63d7d4fa8b14df5e185813794a49d5">More...</a><br /></td></tr>
<tr class="separator:add63d7d4fa8b14df5e185813794a49d5 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bb9a5da26da8829795ebb72e9c666e inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af1bb9a5da26da8829795ebb72e9c666e">sleep</a> ()</td></tr>
<tr class="memdesc:af1bb9a5da26da8829795ebb72e9c666e inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets module to sleep.  <a href="class_physical_layer.html#af1bb9a5da26da8829795ebb72e9c666e">More...</a><br /></td></tr>
<tr class="separator:af1bb9a5da26da8829795ebb72e9c666e inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5da4311092e3df6b193ff303a0c5e8 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a7d5da4311092e3df6b193ff303a0c5e8">standby</a> (uint8_t mode)</td></tr>
<tr class="memdesc:a7d5da4311092e3df6b193ff303a0c5e8 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets module to a specific standby mode.  <a href="class_physical_layer.html#a7d5da4311092e3df6b193ff303a0c5e8">More...</a><br /></td></tr>
<tr class="separator:a7d5da4311092e3df6b193ff303a0c5e8 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dbafeeb9dd9ede72cc4d907738ac48 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a13dbafeeb9dd9ede72cc4d907738ac48">startReceive</a> (uint32_t timeout, uint16_t irqFlags, uint16_t irqMask, size_t len)</td></tr>
<tr class="memdesc:a13dbafeeb9dd9ede72cc4d907738ac48 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. A DIO pin will be activated when full packet is received. Must be implemented in module class.  <a href="class_physical_layer.html#a13dbafeeb9dd9ede72cc4d907738ac48">More...</a><br /></td></tr>
<tr class="separator:a13dbafeeb9dd9ede72cc4d907738ac48 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">setFrequency</a> (float freq)</td></tr>
<tr class="memdesc:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Must be implemented in module class.  <a href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">More...</a><br /></td></tr>
<tr class="separator:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2286dc78dbf8e3084f38e9159b99ae5 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ad2286dc78dbf8e3084f38e9159b99ae5">setOutputPower</a> (int8_t power)</td></tr>
<tr class="memdesc:ad2286dc78dbf8e3084f38e9159b99ae5 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output power. Must be implemented in module class if the module supports it.  <a href="class_physical_layer.html#ad2286dc78dbf8e3084f38e9159b99ae5">More...</a><br /></td></tr>
<tr class="separator:ad2286dc78dbf8e3084f38e9159b99ae5 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">getFreqStep</a> () const</td></tr>
<tr class="memdesc:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the module frequency step size that was set in constructor.  <a href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">More...</a><br /></td></tr>
<tr class="separator:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c3c0866faa474ae2ea8d5b79a73358 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a50c3c0866faa474ae2ea8d5b79a73358">calculateRxTimeout</a> (uint32_t timeoutUs)</td></tr>
<tr class="memdesc:a50c3c0866faa474ae2ea8d5b79a73358 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the timeout value for this specific module / series (in number of symbols or units of time)  <a href="class_physical_layer.html#a50c3c0866faa474ae2ea8d5b79a73358">More...</a><br /></td></tr>
<tr class="separator:a50c3c0866faa474ae2ea8d5b79a73358 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1fe00d107bbc23b0315fd442bc3292 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a1d1fe00d107bbc23b0315fd442bc3292">irqRxDoneRxTimeout</a> (uint16_t &amp;irqFlags, uint16_t &amp;irqMask)</td></tr>
<tr class="memdesc:a1d1fe00d107bbc23b0315fd442bc3292 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the flags that make up RxDone and RxTimeout used for receiving downlinks.  <a href="class_physical_layer.html#a1d1fe00d107bbc23b0315fd442bc3292">More...</a><br /></td></tr>
<tr class="separator:a1d1fe00d107bbc23b0315fd442bc3292 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8d8182a32439fe91f2806d73e629f4 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acb8d8182a32439fe91f2806d73e629f4">isRxTimeout</a> ()</td></tr>
<tr class="memdesc:acb8d8182a32439fe91f2806d73e629f4 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the IRQ bit for RxTimeout is set.  <a href="class_physical_layer.html#acb8d8182a32439fe91f2806d73e629f4">More...</a><br /></td></tr>
<tr class="separator:acb8d8182a32439fe91f2806d73e629f4 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <a href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">More...</a><br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <a href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">More...</a><br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5985308904261dd431f373d47ddee4 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a1a5985308904261dd431f373d47ddee4">randomByte</a> ()</td></tr>
<tr class="memdesc:a1a5985308904261dd431f373d47ddee4 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise. Must be implemented in module class.  <a href="class_physical_layer.html#a1a5985308904261dd431f373d47ddee4">More...</a><br /></td></tr>
<tr class="separator:a1a5985308904261dd431f373d47ddee4 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <a href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">More...</a><br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <a href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">More...</a><br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf96cf4f3cb4c82d44be581dbe615966 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#abf96cf4f3cb4c82d44be581dbe615966">setDirectAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:abf96cf4f3cb4c82d44be581dbe615966 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is received in direct mode. Must be implemented in module class.  <a href="class_physical_layer.html#abf96cf4f3cb4c82d44be581dbe615966">More...</a><br /></td></tr>
<tr class="separator:abf96cf4f3cb4c82d44be581dbe615966 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda61fc99cfa373153c50c78380ed885 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acda61fc99cfa373153c50c78380ed885">readBit</a> (uint32_t pin)</td></tr>
<tr class="memdesc:acda61fc99cfa373153c50c78380ed885 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode. Must be implemented in module class.  <a href="class_physical_layer.html#acda61fc99cfa373153c50c78380ed885">More...</a><br /></td></tr>
<tr class="separator:acda61fc99cfa373153c50c78380ed885 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <a href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">More...</a><br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top"><a id="a429796eb2e7ea86781a2e8ca42af43f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a429796eb2e7ea86781a2e8ca42af43f3">dropSync</a> ()</td></tr>
<tr class="memdesc:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully drop synchronization. <br /></td></tr>
<tr class="separator:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">read</a> (bool drop=true)</td></tr>
<tr class="memdesc:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <a href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">More...</a><br /></td></tr>
<tr class="separator:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349e8a22cd28ad89d45460fdeeefc05c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a349e8a22cd28ad89d45460fdeeefc05c">setDIOMapping</a> (uint32_t pin, uint32_t value)</td></tr>
<tr class="memdesc:a349e8a22cd28ad89d45460fdeeefc05c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO pin mapping to get a given signal on a DIO pin (if available).  <a href="class_physical_layer.html#a349e8a22cd28ad89d45460fdeeefc05c">More...</a><br /></td></tr>
<tr class="separator:a349e8a22cd28ad89d45460fdeeefc05c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae11c191a7edf3116bf468b9153237260">setChannelScanAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a channel scan is finished.  <a href="class_physical_layer.html#ae11c191a7edf3116bf468b9153237260">More...</a><br /></td></tr>
<tr class="separator:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top"><a id="a169a4d04c5c50d3336e274d70930d9f6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a169a4d04c5c50d3336e274d70930d9f6">clearChannelScanAction</a> ()</td></tr>
<tr class="memdesc:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a channel scan is finished. <br /></td></tr>
<tr class="separator:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3ccfd35d26960457214d2a0192d6b312"><td class="memItemLeft" align="right" valign="top"><a id="a3ccfd35d26960457214d2a0192d6b312"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r11x0.html#a3ccfd35d26960457214d2a0192d6b312">XTAL</a></td></tr>
<tr class="memdesc:a3ccfd35d26960457214d2a0192d6b312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the module has an XTAL (true) or TCXO (false). Defaults to false. <br /></td></tr>
<tr class="separator:a3ccfd35d26960457214d2a0192d6b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a562f34a054e3374b812556df3b6eb421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562f34a054e3374b812556df3b6eb421">&#9670;&nbsp;</a></span>LR11x0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LR11x0::LR11x0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> that will be used to communicate with the radio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8dc6468762c36c30e9af262014e17942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc6468762c36c30e9af262014e17942">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::begin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for LoRa modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LoRa bandwidth in kHz. </td></tr>
    <tr><td class="paramname">sf</td><td>LoRa spreading factor. </td></tr>
    <tr><td class="paramname">cr</td><td>LoRa coding rate denominator. </td></tr>
    <tr><td class="paramname">syncWord</td><td>1-byte LoRa sync word. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>LoRa preamble length in symbols </td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abcc4c776d1a09bb002226ac95574766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc4c776d1a09bb002226ac95574766d">&#9670;&nbsp;</a></span>beginGFSK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::beginGFSK </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for FSK modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>FSK bit rate in kbps. </td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation from carrier frequency in kHz. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>FSK preamble length in bits. </td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a858b08fd0e7b00baf3056d32dfabb87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858b08fd0e7b00baf3056d32dfabb87e">&#9670;&nbsp;</a></span>beginLRFHSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::beginLRFHSS </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for LR-FHSS modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LR-FHSS bandwidth, one of RADIOLIB_LR11X0_LR_FHSS_BW_* values. </td></tr>
    <tr><td class="paramname">cr</td><td>LR-FHSS coding rate, one of RADIOLIB_LR11X0_LR_FHSS_CR_* values. </td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a4d18ad719be79c083f2b0ce77bbaa448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d18ad719be79c083f2b0ce77bbaa448">&#9670;&nbsp;</a></span>checkDataRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::checkDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the data rate can be configured by this module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr</td><td>Data rate struct. Interpretation depends on currently active modem (GFSK or LoRa). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a58d54eeb40fb586013ba48e15318abba">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae565dc2423ca7df13bf7ae48cce9ac8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae565dc2423ca7df13bf7ae48cce9ac8b">&#9670;&nbsp;</a></span>disableAddressFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::disableAddressFiltering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables address filtering. Calling this method will also erase previously set addresses. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aaff9a5b9b7636693c98bd1c93a5863e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff9a5b9b7636693c98bd1c93a5863e5">&#9670;&nbsp;</a></span>finishTransmit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::finishTransmit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after transmission is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1de26f68b939f5af79ec29cc34c7be18">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a5df4c1ed45bf59aa25bc400bcb5dc1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df4c1ed45bf59aa25bc400bcb5dc1ba">&#9670;&nbsp;</a></span>fixedPacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::fixedPacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>RADIOLIB_LR11X0_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in fixed packet length mode. Available in GFSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a1ae2cddeb7671d9b71e9c83bf020820f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae2cddeb7671d9b71e9c83bf020820f">&#9670;&nbsp;</a></span>getChannelScanResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::getChannelScanResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the channel scan result. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a63979795a7b53557560bb95b65480906">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a1ec81f3625fdc8a3ef6c54a3804c3aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec81f3625fdc8a3ef6c54a3804c3aa9">&#9670;&nbsp;</a></span>getDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LR11x0::getDataRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets effective data rate for the last transmitted packet. The value is calculated only for payload bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Effective data rate in bps. </dd></dl>

</div>
</div>
<a id="ad9046bccdb4ef60718e2e8ed2bd7f036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9046bccdb4ef60718e2e8ed2bd7f036">&#9670;&nbsp;</a></span>getFrequencyError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LR11x0::getFrequencyError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets frequency error of the latest received packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Frequency error in Hz. </dd></dl>

</div>
</div>
<a id="a0309154558a0d88e2e8957e4dbf6a2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0309154558a0d88e2e8957e4dbf6a2f8">&#9670;&nbsp;</a></span>getIrqStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LR11x0::getIrqStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current IRQ status. </p>
<dl class="section return"><dt>Returns</dt><dd>IRQ status bits </dd></dl>

</div>
</div>
<a id="af96883b2ca7a36a8921ee1cd222adebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96883b2ca7a36a8921ee1cd222adebf">&#9670;&nbsp;</a></span>getPacketLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LR11x0::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

</div>
</div>
<a id="ac1f541bdee1d983126ceae47940b8f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f541bdee1d983126ceae47940b8f9d">&#9670;&nbsp;</a></span>getPacketLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LR11x0::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2fe95169b5cdc8cabe1f2af66cad6ef6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a468ee0182883d8af22a0a4202ef7baa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468ee0182883d8af22a0a4202ef7baa5">&#9670;&nbsp;</a></span>getRSSI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LR11x0::getRSSI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets RSSI (Recorded Signal Strength Indicator) of the last received packet. Only available for LoRa or GFSK modem. </p>
<dl class="section return"><dt>Returns</dt><dd>RSSI of the last received packet in dBm. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aabc94ab27a9ee6daaafa9b47dde5f75b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ad4f32509aea96de6a7ec08a8e60a6bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f32509aea96de6a7ec08a8e60a6bea">&#9670;&nbsp;</a></span>getSNR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LR11x0::getSNR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem. </p>
<dl class="section return"><dt>Returns</dt><dd>SNR of the last received packet in dB. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedddaf9460941b90e43e9005035faa0f">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a33dd234876e6e5dc640302d8456fd7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33dd234876e6e5dc640302d8456fd7ed">&#9670;&nbsp;</a></span>getTimeOnAir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LR11x0::getTimeOnAir </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get expected time-on-air for a given size of payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expected time-on-air in microseconds. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>implement this mess - <a class="el" href="class_s_x1280.html" title="Derived class for SX1280 modules.">SX1280</a> datasheet v3.0 section 7.4.4.2 </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a55ccbe60bfc1ab58814dbd5f9cd4939e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af85c16956c2250dbf338a298c074d28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85c16956c2250dbf338a298c074d28c">&#9670;&nbsp;</a></span>invertIQ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::invertIQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/disable inversion of the I and Q signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>QI inversion enabled (true) or disabled (false); </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a11b4c6d0bf3ae7b9ca04e9434180feab">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3563453988a83d22dd07d4691543a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563453988a83d22dd07d4691543a300">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::readData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retrieved automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a20279f1b267e936991f47fd703924833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20279f1b267e936991f47fd703924833">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retrieved automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab82617fa3fa9f21d4cd427314ecc4af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82617fa3fa9f21d4cd427314ecc4af8">&#9670;&nbsp;</a></span>receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::receive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary receive method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a377c287f18c939c2b4da3241d8329e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377c287f18c939c2b4da3241d8329e58">&#9670;&nbsp;</a></span>receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ab82617fa3fa9f21d4cd427314ecc4af8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae1a8e8eda78113c47f1a865e63051bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a8e8eda78113c47f1a865e63051bb5">&#9670;&nbsp;</a></span>receiveDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::receiveDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts direct mode reception. Only implemented for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, as SX126x series does not support direct mode reception. Will always return RADIOLIB_ERR_UNKNOWN. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad9d1dbb2041e87af5a80e12f125a60e6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a288bcc309d3676bc0bbe620b7d89d994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288bcc309d3676bc0bbe620b7d89d994">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset method. Will reset the chip to the default state using RST pin. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6a3034c91f5bce70c853ab1620725b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3034c91f5bce70c853ab1620725b3c">&#9670;&nbsp;</a></span>scanChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::scanChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs scan for LoRa transmission in the current channel. Detects both preamble and payload. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#abd9e39cc745acbf084cfa0d3f4d10718">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a99ece57e55ee0001671165213b409a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ece57e55ee0001671165213b409a44">&#9670;&nbsp;</a></span>scanChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::scanChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>symbolNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>detPeak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>detMin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scan for LoRa transmission in the current channel. Detects both preamble and payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbolNum</td><td>Number of symbols for CAD detection. </td></tr>
    <tr><td class="paramname">detPeak</td><td>Peak value for CAD detection. </td></tr>
    <tr><td class="paramname">detMin</td><td>Minimum value for CAD detection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abf961ec7d93feb6472f26b7b976ee0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf961ec7d93feb6472f26b7b976ee0c9">&#9670;&nbsp;</a></span>setBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa bandwidth. Allowed values are 62.5, 125.0, 250.0 and 500.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LoRa bandwidth to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a03ab7a24fec379c6ba2d642e1133c4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ab7a24fec379c6ba2d642e1133c4f2">&#9670;&nbsp;</a></span>setBitRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setBitRate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets GFSK bit rate. Allowed values range from 0.6 to 300.0 kbps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>FSK bit rate to be set in kbps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedd39ad84b45c6392087b12d59192d8c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af24ba794f71c4e37cd13d2f4dbec5bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24ba794f71c4e37cd13d2f4dbec5bf7">&#9670;&nbsp;</a></span>setBroadcastAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setBroadcastAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>broadAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets broadcast address. Calling this method will also enable address filtering for node and broadcast address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadAddr</td><td>Node address to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a583f2d5ed601a98c609dbf0d57f2f541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583f2d5ed601a98c609dbf0d57f2f541">&#9670;&nbsp;</a></span>setCodingRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setCodingRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>longInterleave</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa coding rate denominator. Allowed values range from 5 to 8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>LoRa coding rate denominator to be set. </td></tr>
    <tr><td class="paramname">longInterleave</td><td>Enable long interleaver when set to true. Note that CR 4/7 is not possible with long interleaver enabled! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a551b82787288b0b14e4d3124e6744dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551b82787288b0b14e4d3124e6744dc3">&#9670;&nbsp;</a></span>setCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setCRC </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial</em> = <code>0x00001D0FUL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>polynomial</em> = <code>0x00001021UL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets CRC configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>CRC length in bytes, Allowed values are 1 or 2, set to 0 to disable CRC. </td></tr>
    <tr><td class="paramname">initial</td><td>Initial CRC value. GFSK only. Defaults to 0x1D0F (CCIT CRC). </td></tr>
    <tr><td class="paramname">polynomial</td><td>Polynomial for CRC calculation. GFSK only. Defaults to 0x1021 (CCIT CRC). </td></tr>
    <tr><td class="paramname">inverted</td><td>Invert CRC bytes. GFSK only. Defaults to true (CCIT CRC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a056e65c58ff8fb18bd84917512790ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e65c58ff8fb18bd84917512790ee6">&#9670;&nbsp;</a></span>setDataRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr</td><td>Data rate struct. Interpretation depends on currently active modem (GFSK or LoRa). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a6ee1fed6bbb8d3571974153ac6f26751">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a5a33df702da3f5b010e07d5e6fac7aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a33df702da3f5b010e07d5e6fac7aa6">&#9670;&nbsp;</a></span>setDataShaping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setDataShaping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets time-bandwidth product of Gaussian filter applied for shaping. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5, RADIOLIB_SHAPING_0_7 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Time-bandwidth product of Gaussian filter to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aeba04366a0cf05ff3d8227c4f7c8e1e9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a8ae178a17f6e41b545b79cfffd3e2864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae178a17f6e41b545b79cfffd3e2864">&#9670;&nbsp;</a></span>setEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setEncoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission encoding. Available in GFSK mode only. Serves only as alias for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>Encoding to be used. Set to 0 for NRZ, and 2 for whitening. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acb45b2342400a03a914a91d2ac7fb488">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ac003cfe3a4dbd9bad1f01fd0147031d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac003cfe3a4dbd9bad1f01fd0147031d1">&#9670;&nbsp;</a></span>setFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets GFSK frequency deviation. Allowed values range from 0.0 to 200.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqDev</td><td>GFSK frequency deviation to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2f4f9b428d9ea9af886ca85e5088ed7b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a49116d006b60128fe6f73a6a868a6d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49116d006b60128fe6f73a6a868a6d18">&#9670;&nbsp;</a></span>setIrqAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LR11x0::setIrqAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when IRQ1 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c1def9a01021a52f5bb82c119a9ad35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1def9a01021a52f5bb82c119a9ad35">&#9670;&nbsp;</a></span>setLrFhssConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setLrFhssConfig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hdrCount</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hopSeed</em> = <code>0x13A</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LR-FHSS configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LR-FHSS bandwidth, one of RADIOLIB_LR11X0_LR_FHSS_BW_* values. </td></tr>
    <tr><td class="paramname">cr</td><td>LR-FHSS coding rate, one of RADIOLIB_LR11X0_LR_FHSS_CR_* values. </td></tr>
    <tr><td class="paramname">hdrCount</td><td>Header packet count, 1 - 4. Defaults to 3. </td></tr>
    <tr><td class="paramname">hopSeed</td><td>9-bit seed number for PRNG generation of the hopping sequence. Defaults to 0x13A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a605f5c74ce523abad256866abe133d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605f5c74ce523abad256866abe133d2e">&#9670;&nbsp;</a></span>setNodeAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setNodeAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nodeAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets node address. Calling this method will also enable address filtering for node address only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeAddr</td><td>Node address to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a0a4d48bf33fe466ea4c14cd9db228dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4d48bf33fe466ea4c14cd9db228dce">&#9670;&nbsp;</a></span>setPacketReceivedAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LR11x0::setPacketReceivedAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when a packet is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aec928bb26f65752aa20cd236fbabb95c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a88ff8c277e340c3273fb5715cd743cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ff8c277e340c3273fb5715cd743cce">&#9670;&nbsp;</a></span>setPacketSentAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LR11x0::setPacketSentAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when a packet is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a32b512b34f6575b2109ae3c3f35d1369">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa5d7ae65666f8f9abcb7e9b169884a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d7ae65666f8f9abcb7e9b169884a4a">&#9670;&nbsp;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>preambleLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets preamble length for LoRa or GFSK modem. Allowed values range from 1 to 65535. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preambleLength</td><td>Preamble length to be set in symbols (LoRa) or bits (GFSK). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a85db1ff64e6c56e054f276c511194633">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a25f5ee68b3c2638ae613c87ed1c3fc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f5ee68b3c2638ae613c87ed1c3fc64">&#9670;&nbsp;</a></span>setRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setRxBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets GFSK receiver bandwidth. Allowed values are 4.8, 5.8, 7.3, 9.7, 11.7, 14.6, 19.5, 23.4, 29.3, 39.0, 46.9, 58.6, 78.2, 93.8, 117.3, 156.2, 187.2, 234.3, 312.0, 373.6 and 467.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxBw</td><td>GFSK receiver bandwidth to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adf6895cbf7af7e00ea06c5b2b5040cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6895cbf7af7e00ea06c5b2b5040cb4">&#9670;&nbsp;</a></span>setSpreadingFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setSpreadingFactor </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>legacy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa spreading factor. Allowed values range from 5 to 12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sf</td><td>LoRa spreading factor to be set. </td></tr>
    <tr><td class="paramname">legacy</td><td>Enable legacy mode for SF6 - this allows to communicate with <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> at SF6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6501ef362df1a5b71927cfe4e43c202d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6501ef362df1a5b71927cfe4e43c202d">&#9670;&nbsp;</a></span>setSyncBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setSyncBits </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitsLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets GFSK sync word in the form of array of up to 8 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>GFSK sync word to be set. </td></tr>
    <tr><td class="paramname">bitsLen</td><td>GFSK sync word length in bits. If length is not divisible by 8, least significant bits of syncWord will be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a7ffa48f1b6aaaa3f48e4b51f8ada59d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffa48f1b6aaaa3f48e4b51f8ada59d8">&#9670;&nbsp;</a></span>setSyncWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>syncWord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa or LR-FHSS sync word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>LoRa or LR-FHSS sync word to be set. For LoRa, only 8 least significant bits will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab8c54b1b105605ffe0908c5ff9362932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c54b1b105605ffe0908c5ff9362932">&#9670;&nbsp;</a></span>setSyncWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets GFSK sync word in the form of array of up to 8 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>GFSK sync word to be set. </td></tr>
    <tr><td class="paramname">len</td><td>GFSK sync word length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a6c71cdc1238e1368274670758431a977">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a971b4ccd1d5479e9d72aa9649e8fef55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971b4ccd1d5479e9d72aa9649e8fef55">&#9670;&nbsp;</a></span>setTCXO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setTCXO </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets TCXO (Temperature Compensated Crystal Oscillator) configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltage</td><td>TCXO reference voltage in volts. Allowed values are 1.6, 1.7, 1.8, 2.2. 2.4, 2.7, 3.0 and 3.3 V. Set to 0 to disable TCXO. NOTE: After setting this parameter to 0, the module will be reset (since there's no other way to disable TCXO). </td></tr>
    <tr><td class="paramname">delay</td><td>TCXO timeout in us. Defaults to 5000 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adcde55b8660c24cf5783942a4132786d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcde55b8660c24cf5783942a4132786d">&#9670;&nbsp;</a></span>setWhitening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::setWhitening </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>initial</em> = <code>0x01FF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets GFSK whitening parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True = Whitening enabled </td></tr>
    <tr><td class="paramname">initial</td><td>Initial value used for the whitening LFSR in GFSK mode. By default set to 0x01FF for compatibility with <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> and LoRaWAN. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a64d70a3341a6a8b32f9871cdcb719733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d70a3341a6a8b32f9871cdcb719733">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::sleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retainConfig</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sleepTime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module to sleep mode. To wake the device up, call <a class="el" href="class_l_r11x0.html#a74c3f3f8409f1fd0f41347b7d3c7dc24" title="Sets the module to standby mode (overload for PhysicalLayer compatibility, uses 13 MHz RC oscillator)...">standby()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retainConfig</td><td>Set to true to retain configuration of the currently active modem ("warm start") or to false to discard current configuration ("cold start"). Defaults to true. </td></tr>
    <tr><td class="paramname">sleepTime</td><td>Sleep duration (enables automatic wakeup), in multiples of 30.52 us. Ignored if set to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a74c3f3f8409f1fd0f41347b7d3c7dc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c3f3f8409f1fd0f41347b7d3c7dc24">&#9670;&nbsp;</a></span>standby() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::standby </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby mode (overload for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, uses 13 MHz RC oscillator). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acbcaf6aefcb77a354797e66222fe5018">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2d682ec2ca0ddf4da41a93dd8e728665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d682ec2ca0ddf4da41a93dd8e728665">&#9670;&nbsp;</a></span>standby() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::standby </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module to standby mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Oscillator to be used in standby mode. Can be set to RADIOLIB_LR11X0_STANDBY_RC (13 MHz RC oscillator) or RADIOLIB_LR11X0_STANDBY_XOSC (32 MHz external crystal oscillator). </td></tr>
    <tr><td class="paramname">wakeup</td><td>Whether to force the module to wake up. Setting to true will immediately attempt to wake up the module. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a4f3bc362530b85dd643669705f03998d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3bc362530b85dd643669705f03998d">&#9670;&nbsp;</a></span>startChannelScan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::startChannelScan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven channel activity detection method. IRQ1 will be activated when LoRa preamble is detected, or upon timeout. Defaults to CAD parameter values recommended by AN1200.48. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae30dfbb5445bb674898fc54f5f90b2f9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa09eb53b0c32a5f229e14c46bfe45a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09eb53b0c32a5f229e14c46bfe45a4f">&#9670;&nbsp;</a></span>startChannelScan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::startChannelScan </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>symbolNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>detPeak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>detMin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven channel activity detection method. IRQ1 will be activated when LoRa preamble is detected, or upon timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbolNum</td><td>Number of symbols for CAD detection. </td></tr>
    <tr><td class="paramname">detPeak</td><td>Peak value for CAD detection. </td></tr>
    <tr><td class="paramname">detMin</td><td>Minimum value for CAD detection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aabc154b86d9159fb5f769f62418d52b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc154b86d9159fb5f769f62418d52b7">&#9670;&nbsp;</a></span>startReceive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::startReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method with default parameters. Implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a18664ad615c5507ff1690baaca90b094">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a437eaf0e0541983751abd28db45efea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437eaf0e0541983751abd28db45efea8">&#9670;&nbsp;</a></span>startReceive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::startReceive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irqFlags</em> = <code>RADIOLIB_LR11X0_IRQ_RX_DONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven receive method. IRQ1 will be activated when full packet is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Raw timeout value, expressed as multiples of 1/32.768 kHz (approximately 30.52 us). Defaults to RADIOLIB_LR11X0_RX_TIMEOUT_INF for infinite timeout (Rx continuous mode), set to RADIOLIB_LR11X0_RX_TIMEOUT_NONE for no timeout (Rx single mode). If timeout other than infinite is set, signal will be generated on IRQ1.</td></tr>
    <tr><td class="paramname">irqFlags</td><td>Sets the IRQ flags that will trigger IRQ1, defaults to RADIOLIB_LR11X0_IRQ_RX_DONE. </td></tr>
    <tr><td class="paramname">len</td><td>Only for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a923654706eff5118ef6e84214e837f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923654706eff5118ef6e84214e837f27">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ad59e37ce0606dc8051e40be9d14cfec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59e37ce0606dc8051e40be9d14cfec3">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a548ab2acdf0e2a6c621be3a267119fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548ab2acdf0e2a6c621be3a267119fcd">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::startTransmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send. </td></tr>
    <tr><td class="paramname">addr</td><td>Address to send the data to. Will only be added if address filtering was enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad59e37ce0606dc8051e40be9d14cfec3">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a492b2d057dd803c3884fa1adc8e22534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b2d057dd803c3884fa1adc8e22534">&#9670;&nbsp;</a></span>transmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-string transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a3dd42f8d5569487ea74f004ca652a709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd42f8d5569487ea74f004ca652a709">&#9670;&nbsp;</a></span>transmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary transmit method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a3a1de95be55f7ecc1d26a7aa7983cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1de95be55f7ecc1d26a7aa7983cdba">&#9670;&nbsp;</a></span>transmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send. </td></tr>
    <tr><td class="paramname">addr</td><td>Address to send the data to. Will only be added if address filtering was enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3dd42f8d5569487ea74f004ca652a709">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae077957969f6274a53f63b314b6f1359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae077957969f6274a53f63b314b6f1359">&#9670;&nbsp;</a></span>transmitDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::transmitDirect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts direct mode transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>Raw RF frequency value. Defaults to 0, required for quick frequency shifts in RTTY. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aa4c99ac794ee653c2061be4201724b65">PhysicalLayer</a>.</p>

</div>
</div>
<a id="adcd56cf63e91449b6cd03782a69c3451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd56cf63e91449b6cd03782a69c3451">&#9670;&nbsp;</a></span>variablePacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR11x0::variablePacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>RADIOLIB_LR11X0_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in variable packet length mode. Available in GFSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLen</td><td>Maximum packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/LR11x0/<a class="el" href="_l_r11x0_8h_source.html">LR11x0.h</a></li>
<li>src/modules/LR11x0/LR11x0.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_l_r11x0.html">LR11x0</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
